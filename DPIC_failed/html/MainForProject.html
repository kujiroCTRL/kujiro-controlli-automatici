
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Script per l'analisi e controllo di un doppio pendolo inverso su carrello mobile (sistema DPIC)</title><meta name="generator" content="MATLAB 9.13"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2023-02-13"><meta name="DC.source" content="MainForProject.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Script per l'analisi e controllo di un doppio pendolo inverso su carrello mobile (sistema DPIC)</h1><p>Pulizia dello spazio di lavoro</p><pre class="codeinput">clear
close <span class="string">all</span>
clc
</pre><p>Creazione delle variabili simboliche per le caratteristiche del sistema (variabili nel tempo e costanti)</p><pre class="codeinput">syms <span class="string">x0(t)</span> <span class="string">t1(t)</span> <span class="string">t2(t)</span> <span class="string">m0</span> <span class="string">m1</span> <span class="string">m2</span> <span class="string">J1</span> <span class="string">J2</span> <span class="string">L1</span> <span class="string">L2</span> <span class="string">g</span>
<span class="comment">% Posizione del CoM del primo braccio</span>
x1 = x0 + L1 / 2 * sin(t1);
y1 = - L1 / 2 * cos(t1);
<span class="comment">% Posizione del CoM del secondo braccio</span>
x2 = x1 + L1 / 2 * sin(t1) + L2 / 2 * sin(t2);
y2 = y1 - L1 / 2 * cos(t1) - L2 / 2 * cos(t2);
<span class="comment">% Posizione terminale del DPI</span>
xt = x2 + L2 / 2 * sin(t2);
yt = y2 - L2 / 2 * cos(t2);
<span class="comment">% Calcolo delle velocit&agrave; lineari</span>
v0 = diff(x0);
vx1 = diff(x1);
vy1 = diff(y1);
vx2 = diff(x2);
vy2 = diff(y2);
<span class="comment">% Calcolo delle velocit&agrave; angolari</span>
w1 = diff(t1);
w2 = diff(t2);
</pre><p>Calcolo del lagrangiano LGR = KE - PE e derivate parziali rispetto alle posizioni <img src="MainForProject_eq13415924984089450490.png" alt="$x_0, \vartheta_1, \vartheta_2$"> e alle velocit&agrave; <img src="MainForProject_eq03337551261460634499.png" alt="$v_0, \omega_1, \omega_2$"></p><pre class="codeinput">KE = .5 * (m0 * v0 ^ 2 <span class="keyword">...</span>
    + m1 * vx1 ^ 2 + m1 * vy1 ^ 2 <span class="keyword">...</span>
    + m2  * vx2 ^ 2 + m2 * vy2 ^ 2 <span class="keyword">...</span>
    + J1 * w1 ^ 2 + J2 * w2 ^ 2);
PE = - m1 * g * y1 - m2 * g * y2;
LGR = KE - PE;
</pre><p>Rimpiazzo le accelerazioni degli stati con variabili simboliche (utile per semplificare l'espressione di queste ultime in termini delle altre variabili di stato)</p><pre class="codeinput">syms <span class="string">a0</span> <span class="string">u1</span> <span class="string">u2</span> <span class="string">u(t)</span>;
ddQ = [a0, u1, u2];
</pre><p>Calcolo delle forze agenti sul sistema</p><p><img src="MainForProject_eq07043812754798436462.png" alt="$$F_{ext} = \partial_t\partial_{\dot q} L_{GR} -&#xA;\partial_q L_{GR}$$"></p><pre class="codeinput">F = subs([ <span class="keyword">...</span>
    diff(diff(LGR, v0)) - diff(LGR, x0), <span class="keyword">...</span>
    diff(diff(LGR, w1)) - diff(LGR, t1), <span class="keyword">...</span>
    diff(diff(LGR, w2)) - diff(LGR, t2) <span class="keyword">...</span>
], [diff(v0), diff(w1), diff(w2)], ddQ);
F = simplify(F);
</pre><p>Scelgo come forze esterne agenti sul sistema la forza (attuabile) sul carrello <img src="MainForProject_eq17747544483164529551.png" alt="$u(t)$"> e le forze di disspazione che sono lineari nelle velocit&agrave; <img src="MainForProject_eq11626716184460683147.png" alt="$d_0v_0, d_1\omega_1, d_2\omega_2$"></p><pre class="codeinput">syms <span class="string">d0</span> <span class="string">d1</span> <span class="string">d2</span>;
sys = F == [u, 0, 0];
</pre><p>Nota: il sistema &egrave; non lineare nelle variabili di stato <img src="MainForProject_eq04292210094088723755.png" alt="$q=[x_0, \vartheta_1, \vartheta_2]$">, tantomeno nelle variabili estese <img src="MainForProject_eq07683230866840416760.png" alt="$Q = [x_0, \vartheta_1, \vartheta_2, v_0, \omega_1, \omega_2]$">, ma pu&ograve; comunque essere espresso nella forma</p><p><img src="MainForProject_eq10656374677109180941.png" alt="$$ D(q) \cdot \ddot q + C(q) \cdot \dot q + G(q) = U $$"></p><p>dove <img src="MainForProject_eq01206888054951198476.png" alt="$D, C, G$"> sono matrici mentre <img src="MainForProject_eq00330701431757464773.png" alt="$U = [u(t), 0, 0]$"></p><p>Per ottenere le matrici <img src="MainForProject_eq01206888054951198476.png" alt="$D, C, G$"> sostituisco i termini non lineari in <img src="MainForProject_eq02850855315345568976.png" alt="$q,\dot q$"> con nuove variabili simboliche <tt>w1, w2, W1, W2, c1, s1, c2, s2</tt> le ricavabili dalla seguente <tt>subs</tt></p><pre class="codeinput">syms <span class="string">w1(t)</span> <span class="string">W1</span> <span class="string">w2(t)</span> <span class="string">W2</span> <span class="string">c1</span> <span class="string">s1</span> <span class="string">c2</span> <span class="string">s2</span> <span class="string">cd</span> <span class="string">sd</span>;
sys = subs(sys, [ <span class="keyword">...</span>
    diff(t1, t) ^ 2, diff(t2, t) ^ 2, cos(t1), sin(t1), cos(t2), sin(t2), cos(t1 - t2), sin(t1 - t2)], <span class="keyword">...</span>
    [w1 * W1, w2 * W2, c1, s1, c2, s2, cd, sd] <span class="keyword">...</span>
    );
disp(transpose(sys));
</pre><pre class="codeoutput">   a0*m0 + a0*m1 + a0*m2 + (L1*c1*m1*u1)/2 + L1*c1*m2*u1 + (L2*c2*m2*u2)/2 - (L1*W1*m1*s1*w1(t))/2 - L1*W1*m2*s1*w1(t) - (L2*W2*m2*s2*w2(t))/2 == u(t)
J1*u1 + (L1^2*m1*u1)/4 + L1^2*m2*u1 + (L1*a0*c1*m1)/2 + L1*a0*c1*m2 - (L1*g*m1*s1)/2 - L1*g*m2*s1 + (L1*L2*cd*m2*u2)/2 + (L1*L2*W2*m2*sd*w2(t))/2 == 0
                                        J2*u2 + (L2^2*m2*u2)/4 + (L2*a0*c2*m2)/2 - (L2*g*m2*s2)/2 + (L1*L2*cd*m2*u1)/2 - (L1*L2*W1*m2*sd*w1(t))/2 == 0
symbolic function inputs: t
 
</pre><p>Avendo fatto questa sostituzione possiamo usare la funzione <tt>equationsToMatrix</tt> per ottenere le matrici <img src="MainForProject_eq01206888054951198476.png" alt="$D, C, G$"></p><p>Per ottenere <img src="MainForProject_eq11414838477267473978.png" alt="$D$"> scegliamo variabili da linearizzare come prodotto di matrici <img src="MainForProject_eq00490216844294390673.png" alt="$a_0, u_1, u_2$">; per <img src="MainForProject_eq08596374860807106346.png" alt="$C$"> scegliamo <img src="MainForProject_eq07645649494856406262.png" alt="$x_0,\omega_1,\omega_2$"> (non scegliamo <img src="MainForProject_eq05602840195411959704.png" alt="$v_0$"> in quanto comunque non compare nell'equazione e a quanto sembra MATLAB non riconosce <tt>diff(x0(t), t)</tt> come una variabile simbolica); mentre per <img src="MainForProject_eq03493110191331711391.png" alt="$G$"> scegliamo <img src="MainForProject_eq08202502916237421757.png" alt="$g$"> (per ispezione visiva i termini lineari in questo sistema modificato hanno in comune l'accelerazione gravitazionale <img src="MainForProject_eq08202502916237421757.png" alt="$g$">)</p><pre class="codeinput">D = equationsToMatrix(sys, ddQ);
C = equationsToMatrix(sys, [x0(t), w1(t), w2(t)]);
G = g * equationsToMatrix(sys, g);
</pre><p>Volendo esprimere il sistema del secondo ordine dato da <img src="MainForProject_eq04845508576013897665.png" alt="$D\ddot q+C\dot q+G=U$"> come un sistema del primo ordine possiamo svolgere innanzitutto risolvere l'equazione in termini di <img src="MainForProject_eq15412804321159085541.png" alt="$\ddot q$">:</p><p><img src="MainForProject_eq06484538373907186199.png" alt="$$ \ddot q = D^{-1} U -D^{-1} C \dot q - C^{-1} $$"> Definendo nuova variabile di stato <img src="MainForProject_eq02367739220531965781.png" alt="$Q = [q, \dot q]$"> il sistema pu&ograve; essere scritto come</p><p><img src="MainForProject_eq08386371016944897601.png" alt="$$&#xA;\dot Q = \left[\matrix{0&amp; 1 \cr 0&amp;-D^{-1} C}\right]Q +&#xA;\left[\matrix{0&amp;0\cr D^{-1}&amp; -D^{-1} G}\right]\left[\matrix{U\cr1}\right]&#xA;$$"></p><p>Per rendere matrici <img src="MainForProject_eq13700533046024421851.png" alt="$D, G, C$"> utilizzabili in Simulink possiamo sostituire loro variabili simboliche di partenza</p><pre class="codeinput">D = subs(D, [ <span class="keyword">...</span>
    w1, W1, w2, W2, c1, s1, c2, s2, cd, sd<span class="keyword">...</span>
    ], [ <span class="keyword">...</span>
    diff(t1, t), diff(t1, t), diff(t2, t), diff(t2, t), cos(t1), sin(t1), cos(t2), sin(t2), cos(t1 - t2), sin(t1 - t2)<span class="keyword">...</span>
    ]);
C = subs(C, [ <span class="keyword">...</span>
    w1, W1, w2, W2, c1, s1, c2, s2, cd, sd<span class="keyword">...</span>
    ], [ <span class="keyword">...</span>
    diff(t1, t), diff(t1, t), diff(t2, t), diff(t2, t), cos(t1), sin(t1), cos(t2), sin(t2), cos(t1 - t2), sin(t1 - t2)<span class="keyword">...</span>
    ]);
G = subs(G, [ <span class="keyword">...</span>
    w1, W1, w2, W2, c1, s1, c2, s2, cd, sd<span class="keyword">...</span>
    ], [ <span class="keyword">...</span>
    diff(t1, t), diff(t1, t), diff(t2, t), diff(t2, t), cos(t1), sin(t1), cos(t2), sin(t2), cos(t1 - t2), sin(t1 - t2)<span class="keyword">...</span>
    ]);
</pre><p>Calcolo le matrici del sistema di primo grado nelle variabili <img src="MainForProject_eq11775016853607289309.png" alt="$Q$"></p><pre class="codeinput">I = inv(D);
H = - I *  C;
J = - I * G;
A = [zeros(3, 3), eye(3); zeros(3, 3), H];
B = [zeros(3, 4); I, J];
</pre><p>Definisco i parametri per la simulazione de modello Simulink</p><pre class="codeinput">states = [diff(x0(t), t), diff(t1(t), t), diff(t2(t), t), x0(t), t1(t), t2(t)];
constsSym = [m0, m1, m2, L1, L2, J1, J2, g];
constsReal = [1.5, .5, .75, .5, .75, 1 / 3 * .5 * .5 ^ 2 , 1 / 3 * .75 * .75 ^ 2, 9.8];
syms <span class="string">X0</span> <span class="string">T1</span> <span class="string">T2</span> <span class="string">V0</span> <span class="string">W1</span> <span class="string">W2</span>;
newstates = [V0 W1 W2 X0 T1 T2];
functA = subs(A, [constsSym, states], [constsReal, newstates])
functB = subs(B, [constsSym, states], [constsReal, newstates])
</pre><pre class="codeoutput"> 
functA =
 
[0, 0, 0, 1,                                                                                                                                                                                                                                                                                                                                                                                               0,                                                                                                                                                                                                                                                                                                                                                                                                     0]
[0, 0, 0, 0,                                                                                                                                                                                                                                                                                                                                                                                               1,                                                                                                                                                                                                                                                                                                                                                                                                     0]
[0, 0, 0, 0,                                                                                                                                                                                                                                                                                                                                                                                               0,                                                                                                                                                                                                                                                                                                                                                                                                     1]
[0, 0, 0, 0,          (W1*sin(T1)*((81*cos(T1 - T2)^2)/256 - 525/512))/(2*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)) + (9*W1*sin(T1 - T2)*((75*cos(T2))/128 - (9*cos(T1)*cos(T1 - T2))/16))/(32*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)),            (9*W2*sin(T2)*((81*cos(T1 - T2)^2)/256 - 525/512))/(32*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)) - (9*W2*sin(T1 - T2)*((63*cos(T1))/64 - (81*cos(T2)*cos(T1 - T2))/256))/(32*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048))]
[0, 0, 0, 0, (W1*sin(T1)*((63*cos(T1))/64 - (81*cos(T2)*cos(T1 - T2))/256))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048) + (9*W1*sin(T1 - T2)*((99*cos(T1 - T2))/64 - (9*cos(T1)*cos(T2))/16))/(16*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)),                 (9*W2*sin(T2)*((63*cos(T1))/64 - (81*cos(T2)*cos(T1 - T2))/256))/(16*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)) - (9*W2*sin(T1 - T2)*((81*cos(T2)^2)/256 - 693/256))/(16*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048))]
[0, 0, 0, 0,                             (W1*sin(T1)*((75*cos(T2))/128 - (9*cos(T1)*cos(T1 - T2))/16))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048) + (9*W1*sin(T1 - T2)*(cos(T1)^2 - 275/96))/(16*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)), (9*W2*sin(T2)*((75*cos(T2))/128 - (9*cos(T1)*cos(T1 - T2))/16))/(16*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)) - (9*W2*sin(T1 - T2)*((99*cos(T1 - T2))/64 - (9*cos(T1)*cos(T2))/16))/(16*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048))]
 
 
functB =
 
[                                                                                                                                                                               0,                                                                                                                                                                                0,                                                                                                                                                                               0,                                                                                                                                                                                                                                                                                                                                                                                              0]
[                                                                                                                                                                               0,                                                                                                                                                                                0,                                                                                                                                                                               0,                                                                                                                                                                                                                                                                                                                                                                                              0]
[                                                                                                                                                                               0,                                                                                                                                                                                0,                                                                                                                                                                               0,                                                                                                                                                                                                                                                                                                                                                                                              0]
[                  ((81*cos(T1 - T2)^2)/256 - 525/512)/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048), (2*((63*cos(T1))/64 - (81*cos(T2)*cos(T1 - T2))/256))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048), (2*((75*cos(T2))/128 - (9*cos(T1)*cos(T1 - T2))/16))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048), (441*sin(T2)*((75*cos(T2))/128 - (9*cos(T1)*cos(T1 - T2))/16))/(80*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)) + (49*sin(T1)*((63*cos(T1))/64 - (81*cos(T2)*cos(T1 - T2))/256))/(5*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048))]
[(2*((63*cos(T1))/64 - (81*cos(T2)*cos(T1 - T2))/256))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048),                    (4*((81*cos(T2)^2)/256 - 693/256))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048),  (4*((99*cos(T1 - T2))/64 - (9*cos(T1)*cos(T2))/16))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048),                     (441*sin(T2)*((99*cos(T1 - T2))/64 - (9*cos(T1)*cos(T2))/16))/(40*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)) + (98*sin(T1)*((81*cos(T2)^2)/256 - 693/256))/(5*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048))]
[ (2*((75*cos(T2))/128 - (9*cos(T1)*cos(T1 - T2))/16))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048),   (4*((99*cos(T1 - T2))/64 - (9*cos(T1)*cos(T2))/16))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048),                             (4*(cos(T1)^2 - 275/96))/((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048),                               (98*sin(T1)*((99*cos(T1 - T2))/64 - (9*cos(T1)*cos(T2))/16))/(5*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048)) + (441*sin(T2)*(cos(T1)^2 - 275/96))/(40*((63*cos(T1)^2)/64 + (675*cos(T2)^2)/2048 + (891*cos(T1 - T2)^2)/1024 - (81*cos(T1)*cos(T2)*cos(T1 - T2))/128 - 5775/2048))]
 
</pre><p>Dalle espressioni cos&igrave; ottenute possiamo notare come <img src="MainForProject_eq10348488793466917580.png" alt="$B$"> dipenda solo da <img src="MainForProject_eq09559092898302299647.png" alt="$\vartheta_1,\vartheta_2$">, mentre <img src="MainForProject_eq08772416954200330719.png" alt="$A$"> solo da <img src="MainForProject_eq18209947468588535210.png" alt="$\vartheta_1,\vartheta_2, \omega_1,\omega_2$"> (nessuna delle due dipende dall'effettiva posizione o velocit&agrave; del carrello)</p><p>Per la simulazione converto le matrici <img src="MainForProject_eq08772416954200330719.png" alt="$A$"> e <img src="MainForProject_eq10348488793466917580.png" alt="$B$"> in funzioni che memorizzo rispettivamente in <tt>functA.m</tt> e <tt>functB.m</tt></p><pre class="codeinput">Q0 = zeros(6, 1);
Q0(2) = .01;
</pre><p>Definisco quindi le condizioni iniziali del sistema (tutti sei i parametri di stato, anche se ai nostri interessi servono solo gli angoli <img src="MainForProject_eq06617941320736835529.png" alt="$\vartheta_1, \vartheta_2$"> delle aste del pendolo)</p><pre class="codeinput">matlabFunction(functA, <span class="string">'File'</span>, <span class="string">'functA.m'</span>);
matlabFunction(functB, <span class="string">'File'</span>, <span class="string">'functB.m'</span>);
</pre><p>Per linearizzare il sistema scelgo come primo punto di equilibrio la configurazione up-up delle aste, corrispondente quindi a <img src="MainForProject_eq02108694702332571169.png" alt="$\vartheta_1=\vartheta_2=0$">, posizione generica <img src="MainForProject_eq02926139360078732637.png" alt="$x_0$"> e velocit&agrave; nulle <img src="MainForProject_eq07754076687444504697.png" alt="$\omega_1=\omega_2=v_0=0$"></p><p>Scelte le condizioni inziali posso usare la formula per l'approssimazione al primo ordine data da</p><p><img src="MainForProject_eq02247688368523197933.png" alt="$$ f(x,u)\approx [\partial_x f(x,u)]_{x=x_0,u=u_0}\cdot&#xA;(x-x_0)+[\partial_u f(x,u)]_{x=x_0,u=u_0}\cdot (u-u_0) $$"></p><p>In realt&agrave;, dalla struttura di <img src="MainForProject_eq03251214756343904618.png" alt="$A, B$"> posso osservare che le uniche parti non lineari del sistema sono date dalle sottomatrici <img src="MainForProject_eq05944011528302841188.png" alt="$A_{[4:6, 5:6]}$"> di <img src="MainForProject_eq08772416954200330719.png" alt="$A$"> e <img src="MainForProject_eq02372585518797200725.png" alt="$B_{[4:6,1:4]}$"> di <img src="MainForProject_eq10348488793466917580.png" alt="$B$"> (usando una notazione simile a quella dell'indicizzazione in <tt>MATLAB</tt>)</p><p>Da questa osservazione, usando la formula sopra riportata per le sole dinamiche non lineari del sistema e svolgendo tutti i calcoli otteniamo l'approssimazione lineare</p><p><img src="MainForProject_eq10601220002085254703.png" alt="$$&#xA;  \dot Q_i\approx\left[ -(\partial_{Q_i} D^{-1}) C Q - D^{-1}(\partial_{Q_i} C)&#xA;  Q -D^{-1} C (\partial_{Q_i} Q) + (\partial_{Q_i}&#xA;  D^{-1})U-(\partial_{Q_i} D^{-1})G - D^{-1}(\partial_{Q_i}&#xA;  G)\right]_{Q=Q_0,U=U_0}(Q-Q_{0}) + \ast (U-U_0)&#xA;$$"></p><pre class="codeinput">Qeq = Q0'
subs(diff(functA, V0), newstates, Qeq)
subs(diff(functA, W1), newstates, Qeq)
subs(diff(functA, W2), newstates, Qeq)
</pre><pre class="codeoutput">
Qeq =

         0    0.0100         0         0         0         0

 
ans =
 
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
 
 
ans =
 
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
 
 
ans =
 
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0]
 
</pre><p>Notiamo che <img src="MainForProject_eq00009151311382340783.png" alt="$\partial_{Q_i} D^{-1}$">, all'equilibrio, &egrave; zero per ogni <img src="MainForProject_eq08984912804010224726.png" alt="$i$"></p><p>Stesso discorso vale per <img src="MainForProject_eq11775016853607289309.png" alt="$Q$"> che, all'equilibrio, &egrave; il vettore di soli zeri e per <img src="MainForProject_eq08596374860807106346.png" alt="$C$"> (verificabile con una <tt>subs</tt> su <tt>C</tt>)</p><p><img src="MainForProject_eq02448591286032001853.png" alt="$$&#xA;  \dot Q_i\approx\left[- D^{-1}(\partial_{Q_i} G)\right]_{Q=Q_0,U=U_0}Q&#xA;  +\ast (U - U_0)&#xA;$$"></p><p>Definisco quindi la matrice <img src="MainForProject_eq08772416954200330719.png" alt="$A$"> per il sistema linearizzato</p><pre class="codeinput">m = subs(I, [states, constsSym], [Qeq, constsReal])
l = subs(jacobian(G, [x0(t), t1(t), t2(t)]), [states, constsSym], [Qeq, constsReal])
linA = double([ <span class="keyword">...</span>
    zeros(3, 3), eye(3, 3); <span class="keyword">...</span>
    - m * l, zeros(3, 3)
])
</pre><pre class="codeoutput"> 
m =
 
[ 242/433,  -456/433,    -16/433]
[-456/433,  3264/433,  -1344/433]
[ -16/433, -1344/433, 22912/3897]
 
 
l =
 
[0,      0,        0]
[0, -49/10,        0]
[0,      0, -441/160]
 

linA =

         0         0         0    1.0000         0         0
         0         0         0         0    1.0000         0
         0         0         0         0         0    1.0000
         0   -5.1603   -0.1018         0         0         0
         0   36.9367   -8.5552         0         0         0
         0  -15.2092   16.2051         0         0         0

</pre><p>Per quanto riguarda <img src="MainForProject_eq10348488793466917580.png" alt="$B$"> effettuo gli stessi calcoli prendendo derivate parziali rispetto ad <img src="MainForProject_eq04054596528756220535.png" alt="$U$"> invece di <img src="MainForProject_eq12205187278040321521.png" alt="$Q_i$"></p><p>Siccome l'unico termine a moltiplicare <img src="MainForProject_eq04054596528756220535.png" alt="$U$"> &egrave; <img src="MainForProject_eq02882735668628765194.png" alt="$D^{-1}$">, la matrice <img src="MainForProject_eq10348488793466917580.png" alt="$B$"> sar&agrave; proprio <img src="MainForProject_eq02882735668628765194.png" alt="$D^{-1}$"> valutata in <img src="MainForProject_eq05699062103452239628.png" alt="$Q_0$"></p><pre class="codeinput">linB = double([zeros(3, 1); m * [1; 0; 0]])
</pre><pre class="codeoutput">
linB =

         0
         0
         0
    0.5589
   -1.0531
   -0.0370

</pre><p>Le matrici <img src="MainForProject_eq03285330058217017488.png" alt="$C,D$"> le scelgo come la matrice della sola componente <img src="MainForProject_eq08696298640351222258.png" alt="$\vartheta_2$"> e 0 (non misuro l'ingresso)</p><pre class="codeinput">linC = [0, 1, zeros(1, 4)]
linD = 0
</pre><pre class="codeoutput">
linC =

     0     1     0     0     0     0


linD =

     0

</pre><p>Converto le matrici del sistema linearizzato nella funzione di trasferimento dell'impianto, usando innanzitutto <tt>ss</tt> seguito da <tt>tf</tt></p><pre class="codeinput">linPtf = tf(ss(linA, linB, linC, linD))
[linPnum, linPden] = tfdata(linPtf);

drawEverythingButSignalResponse(linPtf)
</pre><pre class="codeoutput">
linPtf =
 
                   -1.053 s^2 + 17.38
  -----------------------------------------------------
  s^4 - 4.441e-16 s^3 - 53.14 s^2 + 2.842e-14 s + 468.4
 
Continuous-time transfer function.


ans =
 
            -1.053 s^2 + 1.216e-14 s + 17.38
  ----------------------------------------------------
  s^4 + 6.35e-14 s^3 - 54.19 s^2 - 2.785e-12 s + 485.8
 
Continuous-time transfer function.

</pre><img vspace="5" hspace="5" src="MainForProject_01.png" alt=""> <p>Voglio che il sistema risponda ad errore nullo a riferimenti costanti ed overshoot e settling time pi&ugrave; piccoli possibili</p><p><img src="MainForProject_eq01339913161884579024.png" alt="$$&#xA;  0=\lim_{t\rightarrow+\infty} |e(t)|=\lim_{s\rightarrow+0}\left|s\frac{s^\rho D_CD_P}{s^\rho D_CD_P+\mu&#xA;  N_CN_P}\frac{R_0}{s}\right|=\lim_{s\rightarrow+0}\left|\frac{R_0(s^\rho \mu_{D_P})}{\mu\mu_{N_P}}\right|&#xA;$$"></p><p>Affinch&eacute; il limite sopra riportato sia zero scelgo di inserire un polo all'origine nel controllore e, a questo punto, opto per un controllore PID con un polo all'origine (<img src="MainForProject_eq16659916733389438850.png" alt="$K_I\neq 0$">)</p><pre class="codeinput">S = tf(<span class="string">'s'</span>);
syms <span class="string">s</span> <span class="string">KP</span> <span class="string">KI</span> <span class="string">KD</span>;

numC0 = KD * s^2 + KI + KP * s;
denC0 = s;

[numP, denP] = tfdata(linPtf);
numP = poly2sym(cell2sym(numP), s);
denP = poly2sym(cell2sym(denP), s);

denW0 = expand(numC0 * numP + denC0 * denP);
denW0 = coeffs(denW0, s);
latex(vpa(myRouth(denW0), 3))
</pre><pre class="codeoutput">
ans =

    '\left(\begin{array}{ccc} 17.4\,\mathrm{KI} &amp; 17.4\,\mathrm{KD}-1.05\,\mathrm{KI}+2.84e-14 &amp; -1.05\,\mathrm{KD}-4.44e-16\\ 17.4\,\mathrm{KP}+468.0 &amp; -1.05\,\mathrm{KP}-53.1 &amp; 1.0\\ \frac{17.4\,\mathrm{KI}\,\left(1.05\,\mathrm{KP}+53.1\right)+\left(17.4\,\mathrm{KP}+468.0\right)\,\left(17.4\,\mathrm{KD}-1.05\,\mathrm{KI}+2.84e-14\right)}{17.4\,\mathrm{KP}+468.0} &amp; -\frac{1.0\,\left(17.4\,\mathrm{KI}+\left(1.05\,\mathrm{KD}+4.44e-16\right)\,\left(17.4\,\mathrm{KP}+468.0\right)\right)}{17.4\,\mathrm{KP}+468.0} &amp; 0\\ \frac{\left(17.4\,\mathrm{KP}+468.0\right)\,\left(17.4\,\mathrm{KI}+\left(1.05\,\mathrm{KD}+4.44e-16\right)\,\left(17.4\,\mathrm{KP}+468.0\right)-\frac{1.0\,\left(17.4\,\mathrm{KI}\,\left(1.05\,\mathrm{KP}+53.1\right)+\left(17.4\,\mathrm{KP}+468.0\right)\,\left(17.4\,\mathrm{KD}-1.05\,\mathrm{KI}+2.84e-14\right)\right)\,\left(1.05\,\mathrm{KP}+53.1\right)}{17.4\,\mathrm{KP}+468.0}\right)}{17.4\,\mathrm{KI}\,\left(1.05\,\mathrm{KP}+53.1\right)+\left(17.4\,\mathrm{KP}+468.0\right)\,\left(17.4\,\mathrm{KD}-1.05\,\mathrm{KI}+2.84e-14\right)} &amp; 1.0 &amp; 0\\ -\frac{2.05e-19\,\left(2.61e+69\,{\mathrm{KD}}^2\,\mathrm{KP}+7.05e+70\,{\mathrm{KD}}^2+1.58e+68\,\mathrm{KD}\,\mathrm{KI}\,\mathrm{KP}+7.99e+69\,\mathrm{KD}\,\mathrm{KI}+4.05e+53\,\mathrm{KD}\,{\mathrm{KP}}^2+2.08e+55\,\mathrm{KD}\,\mathrm{KP}+2.68e+56\,\mathrm{KD}+1.5e+68\,{\mathrm{KI}}^2+4.51e+53\,\mathrm{KI}\,\mathrm{KP}+4.69e+54\,\mathrm{KI}+1.71e+38\,{\mathrm{KP}}^2+6.3e+38\,\mathrm{KP}-1.07e+41\right)}{4.12e+52\,\mathrm{KD}+3.01e+51\,\mathrm{KI}+6.75e+36\,\mathrm{KP}+7.88e+34\,{\mathrm{KP}}^2+1.53e+51\,\mathrm{KD}\,\mathrm{KP}+3.09e+49\,\mathrm{KI}\,\mathrm{KP}+1.25e+38} &amp; 0 &amp; 0\\ 1.0 &amp; 0 &amp; 0 \end{array}\right)'

</pre><p>Dalla tabella di Routh possiamo osservare che affinch&eacute; la prima colonna sia positiva dovremmo avere <img src="MainForProject_eq08054609311321873125.png" alt="$K_I&gt;0$">, <img src="MainForProject_eq15288544397117393366.png" alt="$K_P&gt; 468 / 17.4\approx 27$"></p><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2022b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Script per l'analisi e controllo di un doppio pendolo inverso su carrello mobile (sistema DPIC)
%
% Pulizia dello spazio di lavoro
%
clear
close all
clc
%%
%
% Creazione delle variabili simboliche per 
    % le caratteristiche del sistema (variabili nel tempo e costanti)
%
syms x0(t) t1(t) t2(t) m0 m1 m2 J1 J2 L1 L2 g
% Posizione del CoM del primo braccio
x1 = x0 + L1 / 2 * sin(t1);
y1 = - L1 / 2 * cos(t1);
% Posizione del CoM del secondo braccio
x2 = x1 + L1 / 2 * sin(t1) + L2 / 2 * sin(t2);
y2 = y1 - L1 / 2 * cos(t1) - L2 / 2 * cos(t2);
% Posizione terminale del DPI
xt = x2 + L2 / 2 * sin(t2);
yt = y2 - L2 / 2 * cos(t2);
% Calcolo delle velocità lineari
v0 = diff(x0);
vx1 = diff(x1);
vy1 = diff(y1);
vx2 = diff(x2);
vy2 = diff(y2);
% Calcolo delle velocità angolari
w1 = diff(t1);
w2 = diff(t2);
%%
%
% Calcolo del lagrangiano LGR = KE - PE e derivate parziali rispetto alle posizioni
% $x_0, \vartheta_1, \vartheta_2$ e alle velocità $v_0, \omega_1, \omega_2$
%   
KE = .5 * (m0 * v0 ^ 2 ...
    + m1 * vx1 ^ 2 + m1 * vy1 ^ 2 ...
    + m2  * vx2 ^ 2 + m2 * vy2 ^ 2 ...
    + J1 * w1 ^ 2 + J2 * w2 ^ 2);
PE = - m1 * g * y1 - m2 * g * y2;
LGR = KE - PE; 
%%
%
% Rimpiazzo le accelerazioni degli stati con variabili simboliche (utile
% per semplificare l'espressione di queste ultime in termini delle altre
% variabili di stato)
%
syms a0 u1 u2 u(t);
ddQ = [a0, u1, u2];
%%
%
% Calcolo delle forze agenti sul sistema
%%
% $$F_{ext} = \partial_t\partial_{\dot q} L_{GR} -
% \partial_q L_{GR}$$
%
F = subs([ ...
    diff(diff(LGR, v0)) - diff(LGR, x0), ...
    diff(diff(LGR, w1)) - diff(LGR, t1), ...
    diff(diff(LGR, w2)) - diff(LGR, t2) ...
], [diff(v0), diff(w1), diff(w2)], ddQ);
F = simplify(F);
%%
%
% Scelgo come forze esterne agenti sul sistema
% la forza (attuabile) sul carrello $u(t)$ e le forze di disspazione che
% sono lineari nelle velocità $d_0v_0, d_1\omega_1, d_2\omega_2$
%
syms d0 d1 d2;
sys = F == [u, 0, 0];
%%
%
% Nota: il sistema è non lineare nelle variabili di stato
% $q=[x_0, \vartheta_1, \vartheta_2]$, tantomeno nelle
% variabili estese $Q = [x_0, \vartheta_1, \vartheta_2, v_0,
% \omega_1, \omega_2]$, ma può comunque essere espresso nella forma
%%
%
% $$ D(q) \cdot \ddot q + C(q) \cdot \dot q + G(q) = U $$
%
% dove $D, C, G$ sono matrici mentre $U = [u(t), 0, 0]$
%
%%
% 
% Per ottenere le matrici $D, C, G$ sostituisco i termini non lineari in
% $q,\dot q$ con nuove variabili simboliche |w1, w2, W1, W2, c1, s1, c2, s2|
% le ricavabili dalla seguente |subs|
%
syms w1(t) W1 w2(t) W2 c1 s1 c2 s2 cd sd;
sys = subs(sys, [ ...
    diff(t1, t) ^ 2, diff(t2, t) ^ 2, cos(t1), sin(t1), cos(t2), sin(t2), cos(t1 - t2), sin(t1 - t2)], ...
    [w1 * W1, w2 * W2, c1, s1, c2, s2, cd, sd] ...
    );
disp(transpose(sys));
%%
%
% Avendo fatto questa sostituzione possiamo usare la funzione
% |equationsToMatrix| per ottenere le matrici $D, C, G$
%%
%
% Per ottenere $D$ scegliamo variabili da linearizzare come
% prodotto di matrici $a_0, u_1, u_2$; per $C$
% scegliamo $x_0,\omega_1,\omega_2$ (non scegliamo $v_0$ in quanto comunque non
% compare nell'equazione e a quanto sembra MATLAB non riconosce
% |diff(x0(t), t)| come una variabile simbolica); mentre per $G$ scegliamo
% $g$ (per ispezione visiva i termini lineari in questo sistema modificato
% hanno in comune l'accelerazione gravitazionale $g$)
%
D = equationsToMatrix(sys, ddQ);
C = equationsToMatrix(sys, [x0(t), w1(t), w2(t)]);
G = g * equationsToMatrix(sys, g);
%%
%
% Volendo esprimere il sistema del secondo ordine dato da $D\ddot q+C\dot q+G=U$
% come un sistema del primo ordine possiamo svolgere innanzitutto risolvere
% l'equazione in termini di $\ddot q$:
%
%% 
% 
% $$ \ddot q = D^{-1} U -D^{-1} C \dot q - C^{-1} $$
% Definendo nuova variabile di stato $Q = [q, \dot q]$ il sistema può
% essere scritto come
%
%%
% 
% $$
% \dot Q = \left[\matrix{0& 1 \cr 0&-D^{-1} C}\right]Q +
% \left[\matrix{0&0\cr D^{-1}& -D^{-1} G}\right]\left[\matrix{U\cr1}\right] 
% $$
%
%%
% Per rendere matrici $D, G, C$ utilizzabili in Simulink possiamo
% sostituire loro variabili simboliche di partenza
%
D = subs(D, [ ...
    w1, W1, w2, W2, c1, s1, c2, s2, cd, sd...
    ], [ ...
    diff(t1, t), diff(t1, t), diff(t2, t), diff(t2, t), cos(t1), sin(t1), cos(t2), sin(t2), cos(t1 - t2), sin(t1 - t2)...
    ]);
C = subs(C, [ ...
    w1, W1, w2, W2, c1, s1, c2, s2, cd, sd...
    ], [ ...
    diff(t1, t), diff(t1, t), diff(t2, t), diff(t2, t), cos(t1), sin(t1), cos(t2), sin(t2), cos(t1 - t2), sin(t1 - t2)...
    ]);
G = subs(G, [ ...
    w1, W1, w2, W2, c1, s1, c2, s2, cd, sd...
    ], [ ...
    diff(t1, t), diff(t1, t), diff(t2, t), diff(t2, t), cos(t1), sin(t1), cos(t2), sin(t2), cos(t1 - t2), sin(t1 - t2)...
    ]);
%%
%
% Calcolo le matrici del sistema di primo grado nelle variabili $Q$
%
I = inv(D);
H = - I *  C;
J = - I * G;
A = [zeros(3, 3), eye(3); zeros(3, 3), H];
B = [zeros(3, 4); I, J];
%%
%
% Definisco i parametri per la simulazione de modello Simulink
%
states = [diff(x0(t), t), diff(t1(t), t), diff(t2(t), t), x0(t), t1(t), t2(t)];
constsSym = [m0, m1, m2, L1, L2, J1, J2, g];
constsReal = [1.5, .5, .75, .5, .75, 1 / 3 * .5 * .5 ^ 2 , 1 / 3 * .75 * .75 ^ 2, 9.8];
syms X0 T1 T2 V0 W1 W2;
newstates = [V0 W1 W2 X0 T1 T2];
functA = subs(A, [constsSym, states], [constsReal, newstates])
functB = subs(B, [constsSym, states], [constsReal, newstates])
%%
%
% Dalle espressioni così ottenute possiamo notare come $B$ dipenda solo da
% $\vartheta_1,\vartheta_2$, mentre $A$ solo da 
% $\vartheta_1,\vartheta_2, \omega_1,\omega_2$
% (nessuna delle due dipende dall'effettiva posizione
% o velocità del carrello)
%
%%
%
% Per la simulazione converto le matrici $A$ e $B$ in funzioni che
% memorizzo rispettivamente in |functA.m| e |functB.m|
% 
Q0 = zeros(6, 1);
Q0(2) = .01;
%%
% 
% Definisco quindi le condizioni
% iniziali del sistema (tutti sei i parametri di stato, anche se ai nostri interessi servono 
% solo gli angoli $\vartheta_1, \vartheta_2$ delle aste del pendolo)
%
matlabFunction(functA, 'File', 'functA.m');
matlabFunction(functB, 'File', 'functB.m');
%%
%
% Per linearizzare il sistema scelgo come primo punto di equilibrio la
% configurazione up-up delle aste, corrispondente quindi a
% $\vartheta_1=\vartheta_2=0$, posizione generica $x_0$ e velocità
% nulle $\omega_1=\omega_2=v_0=0$
%
%%
%
% Scelte le condizioni inziali posso usare la formula per l'approssimazione
% al primo ordine data da 
%
%%
%
% $$ f(x,u)\approx [\partial_x f(x,u)]_{x=x_0,u=u_0}\cdot
% (x-x_0)+[\partial_u f(x,u)]_{x=x_0,u=u_0}\cdot (u-u_0) $$
%
%%
%
% In realtà, dalla struttura di $A, B$ posso osservare che le uniche parti
% non lineari del sistema sono date dalle sottomatrici $A_{[4:6, 5:6]}$ di
% $A$ e $B_{[4:6,1:4]}$ di $B$ (usando una notazione simile a quella
% dell'indicizzazione in |MATLAB|)
%
%%
%
% Da questa osservazione, usando la formula sopra riportata per le sole
% dinamiche non lineari del sistema e svolgendo tutti i calcoli otteniamo 
% l'approssimazione lineare
%
%%
%
% $$
%   \dot Q_i\approx\left[ -(\partial_{Q_i} D^{-1}) C Q - D^{-1}(\partial_{Q_i} C)
%   Q -D^{-1} C (\partial_{Q_i} Q) + (\partial_{Q_i}
%   D^{-1})U-(\partial_{Q_i} D^{-1})G - D^{-1}(\partial_{Q_i}
%   G)\right]_{Q=Q_0,U=U_0}(Q-Q_{0}) + \ast (U-U_0)
% $$
%
Qeq = Q0'
subs(diff(functA, V0), newstates, Qeq)
subs(diff(functA, W1), newstates, Qeq)
subs(diff(functA, W2), newstates, Qeq)
%%
%
% Notiamo che $\partial_{Q_i} D^{-1}$, all'equilibrio, è zero per ogni $i$
%
%%
% 
% Stesso discorso vale per $Q$ che, all'equilibrio, è il vettore di soli
% zeri e per $C$ (verificabile con una |subs| su |C|)
%
%%
%
% $$
%   \dot Q_i\approx\left[- D^{-1}(\partial_{Q_i} G)\right]_{Q=Q_0,U=U_0}Q
%   +\ast (U - U_0)
% $$
%
%%
% 
% Definisco quindi la matrice $A$ per il sistema linearizzato
%
m = subs(I, [states, constsSym], [Qeq, constsReal])
l = subs(jacobian(G, [x0(t), t1(t), t2(t)]), [states, constsSym], [Qeq, constsReal])
linA = double([ ...
    zeros(3, 3), eye(3, 3); ...
    - m * l, zeros(3, 3)
])
%%
%
% Per quanto riguarda $B$ effettuo gli stessi calcoli prendendo derivate
% parziali rispetto ad $U$ invece di $Q_i$
%
%%
%
% Siccome l'unico termine a moltiplicare $U$ è $D^{-1}$, la matrice $B$
% sarà proprio $D^{-1}$ valutata in $Q_0$
%
linB = double([zeros(3, 1); m * [1; 0; 0]])
%%
%
% Le matrici $C,D$ le scelgo come la matrice della sola componente $\vartheta_2$
% e 0 (non misuro l'ingresso)
%
linC = [0, 1, zeros(1, 4)]
linD = 0
%%
%
% Converto le matrici del sistema linearizzato nella funzione di
% trasferimento dell'impianto, usando innanzitutto |ss| seguito da |tf|
%
linPtf = tf(ss(linA, linB, linC, linD))
[linPnum, linPden] = tfdata(linPtf);

drawEverythingButSignalResponse(linPtf)
%%
%
% Voglio che il sistema risponda ad errore nullo a riferimenti costanti
% ed overshoot e settling time più piccoli possibili
%
%%
%
% $$
%   0=\lim_{t\rightarrow+\infty} |e(t)|=\lim_{s\rightarrow+0}\left|s\frac{s^\rho D_CD_P}{s^\rho D_CD_P+\mu
%   N_CN_P}\frac{R_0}{s}\right|=\lim_{s\rightarrow+0}\left|\frac{R_0(s^\rho \mu_{D_P})}{\mu\mu_{N_P}}\right|
% $$
%
%%
%
% Affinché il limite sopra riportato sia zero scelgo di inserire un polo
% all'origine nel controllore e, a questo punto, opto per un controllore
% PID con un polo all'origine ($K_I\neq 0$)
%
S = tf('s');
syms s KP KI KD;

numC0 = KD * s^2 + KI + KP * s;
denC0 = s;

[numP, denP] = tfdata(linPtf);
numP = poly2sym(cell2sym(numP), s);
denP = poly2sym(cell2sym(denP), s);

denW0 = expand(numC0 * numP + denC0 * denP);
denW0 = coeffs(denW0, s);
latex(vpa(myRouth(denW0), 3))
%%
%
% Dalla tabella di Routh possiamo osservare che affinché la prima colonna
% sia positiva dovremmo avere $K_I>0$, $K_P> 468 / 17.4\approx 27$
%
##### SOURCE END #####
--></body></html>